ğŸ›ï¸  NestQuest: The Temple of Modules
Playing with Nestjs

														               Muhammad Saad Riaz

ğŸ§­ Workshop Overview
Transform engineers into confident NestJS developers through a fun, story-driven adventure.

Format:
ğŸ•’ 3 Days â†’
Day 1: Core Foundations
Day 2: Persistence + GraphQL
Day 3: Real-Time + Microservices + Finale

Style:
ğŸ® Gamified learning â†’ Each concept = a Temple Chamber you unlock via coding quests.


ğŸ”®Why NestJS?
NestJS is:

A progressive Node.js framework built with TypeScript using expressJs (under the hood - can use fastify as well)
Inspired by Angularâ€™s architecture (modular, dependency-injected, testable)
Perfect for building scalable server-side applications


Why itâ€™s great for engineers coming from (Ruby/Java/Kotlin):
âœ… Familiar MVC feel
âœ… Clear conventions & decorators
âœ… Built-in DI, modules, and testing
âœ… Clean migration path from monolith â†’ microservices


âš™ï¸ Core NestJS Concepts Weâ€™ll Master
ğŸ›ï¸ Modules â€” Organize your app into feature boundaries
âš”ï¸ Controllers â€” Handle incoming HTTP requests
ğŸ’¡ Providers & Dependency Injection â€” Core business logic and shared services
ğŸ§© Request-Scoped Providers â€” Create per-request instances for logging or tracing
ğŸ§¬ Lifecycle Hooks â€” Control initialization and graceful shutdown of services
ğŸŒŠ Pipes & Filters â€” Validation & error handling
ğŸŒ Global Filters â€” Centralized, app-wide exception handling
âš™ï¸ Middleware â€” Pre-route logic for logging, auth, and transformations
ğŸ›¡ï¸ Guards & Interceptors â€” Authorization, access control, and response manipulation
ğŸ§± Persistence (TypeORM / MikroORM) â€” Database integration and ORM design

âš™ï¸ Core NestJS Concepts Weâ€™ll Master
ğŸ’¾ Caching â€” Improve performance and reduce redundant queries
ğŸ“‚ File Uploads â€” Handle image, document, and multipart form uploads
ğŸ”® GraphQL â€” Flexible data fetching and schema-driven APIs
ğŸ” Auth + JWT â€” Secure APIs and manage user sessions
ğŸ“¡ WebSockets â€” Real-time updates and event broadcasting
âš™ï¸ Microservices â€” Async communication between distributed services
ğŸ§  Event Emitters â€” In-app asynchronous event handling
ğŸ§ª Testing â€” Unit and E2E testing with Jest and Nestâ€™s testing utilities
ğŸ‘ï¸ Observability â€” Health checks, metrics, and structured logging
ğŸ“œ Config Service â€” Centralized configuration and environment management


âš™ï¸ Core NestJS Concepts Weâ€™ll Master
ğŸ¯ Chamber
Concept
Description
ğŸ›ï¸ 1. Modules
Organize your app into feature boundaries
Group controllers, services, and providers logically.
âš”ï¸ 2. Controllers
Handle incoming HTTP requests
Define routes and map them to service logic.
ğŸ’¡ 3. Providers & DI
Core business logic and shared services
Injectable classes managed by Nestâ€™s DI container.
ğŸ§© 4. Request-Scoped Providers
Per-request instances
Create unique service instances per request for logs or tracing.
ğŸ§¬ 5. Lifecycle Hooks
Initialization & shutdown control
Run setup or teardown logic via hooks like OnModuleInit.
ğŸŒŠ 6. Pipes & Filters
Validation & error handling
Transform input, validate data, and catch exceptions.
ğŸŒ 7. Global Filters
App-wide exception handling
Centralize error handling with global filters using APP_FILTER.
âš™ï¸ 8. Middleware
Pre-route logic
Execute logic before requests reach controllers (logging, parsing, auth checks).
ğŸ›¡ï¸ 9. Guards & Interceptors
Auth & response manipulation
Control access (CanActivate) and modify responses (NestInterceptor).
ğŸ§± 10. Persistence (TypeORM / MikroORM)
Database integration
Manage entities, relations, and migrations.

âš™ï¸ Core NestJS Concepts Weâ€™ll Master
ğŸ¯ Chamber
Concept
Description
ğŸ’¾ 11. Caching
Performance optimization
Cache responses or computed data with in-memory or Redis backends.
ğŸ“‚ 12. File Uploads
Handle file and image uploads
Use Multer-based interceptors for single or multiple file uploads.
ğŸ”® 13. GraphQL
Flexible, typed data fetching
Build schema-driven APIs with resolvers, queries, and mutations.
ğŸ” 14. Auth + JWT
Secure APIs
Protect routes using JWT, Guards, and Passport strategies.
ğŸ“¡ 15. WebSockets
Real-time updates
Communicate bi-directionally using @WebSocketGateway().
âš™ï¸ 16. Microservices
Async communication
Connect distributed services via message patterns (TCP, Redis, RabbiqMQ).
ğŸ§  17. Event Emitters
In-app asynchronous events
Emit and listen to domain events within the app without tight coupling.
ğŸ§ª 18. Testing
Unit & E2E tests
Validate logic and endpoints using Jest and Nestâ€™s TestingModule utilities.
ğŸ‘ï¸ 19. Observability
Health, metrics, monitoring
Add /healthz, metrics, and structured logs for visibility.
ğŸ“œ 20. Config Service
Centralized configuration
Manage .env files, environment variables, and validate them with Joi.

ğŸ§‘â€ğŸ’» Workshop Structure
Each concept = a Temple Chamber
â†’ unlock with code
â†’ earn artifacts
â†’ progress on the Temple Map
Segment
Format
Duration
Mini-lecture
15 mins
Concept explanation
Hand-on quest
30-45 mins
Guided coding
Discussion & review
10 mins
Q&A/ reflection

ğŸ® The Game: NestQuest
You are adventurers entering the Temple of Modules â€” each coding practice unlocks a new chamber.

How it works:
Each participant has a Temple Map Dashboard
After completing a quest, your chamber lights up ğŸ”†
Earn emoji artifacts like âš”ï¸ ğŸ›¡ï¸ ğŸ”® ğŸ’¡
Work together to fully illuminate the temple

Final Goal:
Build a fully working NestJS API + GraphQL + Realtime app â€” the â€œGolden Moduleâ€ âœ¨



ğŸ¤ Collaboration Rules
No competition â€” only collective success ğŸ†
Everyone must complete each core concept hands-on
Ask questions anytime â€” this is an exploration, not an exam
Pair up during â€œPortal Challengesâ€ to debug and learn together
Celebrate each chamber unlock with your guildmates ğŸ‰

ğŸ’» What Youâ€™ll Build
By the end of the workshop, youâ€™ll have:
âœ… A fully working mvp of NestJS backend
âœ… REST + GraphQL endpoints
âœ… Auth, Validation, and DI mastered
âœ… Real-time WebSocket feed
âœ… Dockerized and ready to deploy

Your code will literally power the Golden Module â€” the Templeâ€™s final awakening.


ğŸ§° What You Need
Pre-Requisites:
Node.js â‰¥ 20
pnpm or npm
Docker Desktop
Git + VSCode
Postman

Accounts:
Local terminal access (for CLI submissions)


âš”ï¸ Rules of the Temple
DO:
âœ… Write clean, modular code
âœ… Commit often
âœ… Help your peers
âœ… Explore beyond examples

DONâ€™T:
ğŸš« Copy-paste without understanding
ğŸš« Skip hands-on â€” each unlock matters

Temple Secret:
Every challenge reveals an Easter egg ğŸ˜‰ â€” watch your logs.


ğŸ—ºï¸ Daily Flow
ğŸ• Day 1:
NestJS Fundamentals â†’ REST Skeleton
Modules, Controllers, Providers, Pipes

ğŸ•‘ Day 2:
Persistence (TypeORM vs MikroORM)
GraphQL + DataLoader
Auth (JWT)

ğŸ•’ Day 3:
WebSockets + Microservices
Observability + Docker
Golden Module Celebration ğŸ‡


ğŸ Endgame: The Golden Module
When every participant completes all 12 Chambers:
ğŸŒŸ The temple glows
ğŸ“¡ Real-time confetti broadcast
ğŸ“œ Everyoneâ€™s name engraved in the Hall of Builders

â€œYou are now a Guardian of the Temple of Modules.â€ ğŸ›ï¸


ğŸ§  Learning Outcomes
After 3 days, ( hopefully ğŸ¤) youâ€™ll confidently:
Able to design scalable NestJS applications
Integrate databases using ORMs
Build APIs (REST + GraphQL)
Implement JWT Auth + Middleware + Guards + Interceptors
Handle real-time WebSockets
Structure production-ready code

Meanwhile: Youâ€™ll understand Node DI, metadata, decorators, and modular design â€” skills that go beyond NestJS itself. 


Day 1

ğŸ“… Agenda
 
Time
Module
Concept
Format
9:30 â€“ 10:30
Opening & Setup & refresher TS
Environment + Repo Clone
Guided
10:30 â€“ 11:15
Chamber 1
ğŸ›ï¸ Modules
Lecture + Hands-on
11:15 â€“ 12:00
Chamber 2
âš”ï¸ Controllers
Lecture + Hands-on
12:00 â€“ 13:30
â€”
Lunch Break
ğŸ±
13:30 â€“ 14:30
Chamber 3
ğŸ’¡ Providers & DI
Lecture + Hands-on
14:30 â€“ 16:00
Chamber 4
ğŸŒŠ Pipes & Filters
Lecture + Hands-on
16:00 â€“ 16:30
â€”
Recap & Temple Checkpoint 1
Discussion

ğŸ‘‹ Letâ€™s Begin the Journey



â€œEvery temple starts with one gate â€” the Module.â€



Next Stop: Modules ğŸ›ï¸
Light your lanterns â€” letâ€™s begin the quest ğŸ”¥

ğŸ§­ Entering the Temple
Theme:
ğŸ›ï¸ Foundations of the Temple â€” Core NestJS Concepts

Focus Areas:
Modules
Controllers
Providers & Dependency Injection
Pipes & Filters

End of Day Goal:
A working REST API with clean architecture, validation, and error handling.


ğŸ§­ Section 1: Why TypeScript for NestJS
	â€¢	JS is dynamic â†’ TypeScript adds types, tooling, safety.
	â€¢	NestJS is built entirely with TypeScript ( can be used with JS as well ).
	Benefits:
	â€¢	Early bug detection
	â€¢	IntelliSense & auto-completion
	â€¢	Predictable APIs between backend modules



ğŸ§© Section 2: Core TypeScript Building Blocks
â€œType Annotations and Inferenceâ€
	â€¢	Explicit vs inferred types.
	â€¢	Avoid any unless absolutely necessary.


ğŸ§© Section 2: Core TypeScript Building Blocks
â€œPrimitive and Special Typesâ€
	â€¢	number, string, boolean, null, undefined, symbol, bigint
	â€¢	Special: any, unknown, never, void


ğŸ§© Section 2: Core TypeScript Building Blocks
â€œObjects and Interfacesâ€
	â€¢	Interfaces define shape of objects.
	â€¢	Optional & readonly properties.



ğŸ§© Section 2: Core TypeScript Building Blocks
â€œType Aliases vs Interfacesâ€
	â€¢	Both define object shapes.
	â€¢	type is more flexible (unions, primitives, etc.).




ğŸ§© Section 2: Core TypeScript Building Blocks
â€œArrays and Tuplesâ€

ğŸ§© Section 2: Core TypeScript Building Blocks
â€œEnumsâ€

âš™ï¸ Section 3: Advanced Type Features
â€œUnion and Intersection Typesâ€

âš™ï¸ Section 3: Advanced Type Features
â€œLiteral and Template Literal Typesâ€

âš™ï¸ Section 3: Advanced Type Features
â€œGenerics: Reusable Type Logicâ€

âš™ï¸ Section 3: Advanced Type Features
â€œUtility Typesâ€

Common built-ins:
	â€¢	Partial<T> â€” makes properties optional
	â€¢	Pick<T, K> â€” selects subset
	â€¢	Omit<T, K> â€” removes keys
	â€¢	Readonly<T> â€” immutable


âš™ï¸ Section 3: Advanced Type Features
â€œType Narrowing & Type Guardsâ€


âš™ï¸ Section 3: Advanced Type Features
â€œClasses and Access Modifiersâ€â€œClasses and Access Modifiersâ€

âš™ï¸ Section 3: Advanced Type Features
â€œAbstract Classes and Interfacesâ€
	â€¢	abstract = base implementation + blueprint
	â€¢	interface = contract only


âš™ï¸ Section 3: Advanced Type Features
â€œDecorators (Preview)â€
	â€¢	Metadata added to classes, methods, or parameters.
	â€¢	Used heavily in NestJS (@Controller, @Injectable, etc.).


ğŸš€ Section 4: Practical Integration with NestJS
â€œDTOs and Validation with Typesâ€

ğŸš€ Section 4: Practical Integration with NestJS
 â€œType Inference with Repositoriesâ€

ğŸš€ Section 4: Practical Integration with NestJS
 â€œResponse Types and API Contractsâ€

ğŸ§  Section 5: TypeScript in Practice
â€œCommon Errors and Fixesâ€
	â€¢	â€œObject is possibly â€˜undefinedâ€™â€ â†’ use optional chaining ?.
	â€¢	â€œType â€˜Xâ€™ is not assignable to type â€˜Yâ€™â€ â†’ ensure proper generics or casting
	â€¢	â€œCannot find name â€˜Reflectâ€™â€ â†’ enable "experimentalDecorators" + "emitDecoratorMetadata"


ğŸ§  Section 5: TypeScript in Practice
â€œFinal Summaryâ€

ğŸ›ï¸ Modules
Purpose:
Organize your app into feature boundaries. 

Think of a Module as:
ğŸ§± The room in your temple â€” each room contains its own logic, guards, and tools.

Key Topics:
@Module( ) anatomy (imports / controllers / providers / exports)
Provider visibility & exports
Dynamic Modules (forRoot, forFeature) â€œDynamic modules are the factories of NestJS â€” they let you create configurable, reusable building blocks.â€
Global Modules @Global( )

Analogy:
â€œModules are like self-contained chambers â€” each knows its purpose and whoâ€™s allowed inside.â€



ğŸ›ï¸ Modules
// guilds.module.ts
import { Module } from '@nestjs/common';
import { GuildsController } from './guilds.controller';
import { GuildsService } from './guilds.service';

@Module({
  controllers: [GuildsController],
  providers: [GuildsService],
  exports: [GuildsService], // share with other modules
})
export class GuildsModule {}


Hands-on Quest:
Build GuildsModule + QuestsModule, wire them into AppModule with empty arrays for controllers, providers and exports.





âš”ï¸ Controllers
Purpose:
Handle incoming requests

Key Topics:
	@Controller() and routing decorators
	Parameter decorators: @Param, @Body, @Query
	Returning JSON & exceptions
	Delegating to Services



âš”ï¸ Controllers
// guilds.controller.ts
import { Controller, Get, Post, Param, Body } from '@nestjs/common';
import { GuildsService } from './guilds.service';

@Controller('guilds')
export class GuildsController {
  constructor(private readonly service: GuildsService) {}

  @Get() list() {
    return this.service.list();
  }

  @Get(':id') byId(@Param('id') id: string) {
    return this.service.byId(id);
  }

  @Post() create(@Body() dto: { name: string }) {
    return this.service.create(dto.name);
  }
}



ğŸ’¡ Providers & Dependency Injection
Purpose:
Power business logic through reusable, injectable services.

Key Topics:
	What is a provider?
	@Injectable() and the DI container
	Provider scopes (singleton, request, transient)
	Custom providers (useClass, useValue, useFactory, useExisting)
	Circular deps & forwardRef

Hands-on Quest:
Inject LoggerService and DateService into existing modules.
Add a factory provider (UUID_PREFIX) and log its injection.


ğŸ’¡ Providers & Dependency Injection
1. Standard Providers
This is the most common type. Nest manages the instantiation of the class for you.

@Injectable()
export class CatsService {
 findAll() {
   return ['British Shorthair', 'Maine Coon'];
 }
}

// Registration in Module
providers: [CatsService]



ğŸ’¡ Providers & Dependency Injection


// Value                                  // Value
providers: [{                             constructor(
 provide: 'CONFIG',                        @Inject('CONFIG') private config: any
 useValue: { port: 3000 }                ) {}
}]





ğŸ’¡ Providers & Dependency Injection
// Class                                  // Class (Identical to Standard)
providers: [{                             constructor(private logger: Logger) {}
 provide: Logger,
 useClass: CloudLogger
}]

// Factory                                // Factory
providers: [{                             constructor(
 provide: 'CONNECTION',                    @Inject('CONNECTION') private conn: any
 useFactory: (cfg: Config) => {          ) {}
   return cfg.connect();
 },
 inject: [Config]
}]


ğŸ’¡ Providers & Dependency Injection
Hands-on Quest:
Create GET /guilds, POST /guilds, GET /guilds/:id.
Auto-serialize responses and throw a NotFoundException when missing.


ğŸ§© Request-Scoped Providers
Purpose:
Create unique provider instances per incoming request â€” useful for tracking request IDs, user context, or tenant data.

Key Concept:
Default providers in NestJS are singletons (shared across all requests).
You can mark a provider as request-scoped, so itâ€™s recreated for each request.

@Injectable({ scope: Scope.REQUEST })
export class RequestLoggerService {
  constructor(@Inject(REQUEST) private request: Request) {}

  log(msg: string) {
    console.log(`[${this.request.url}] ${msg}`);
  }
}
â€œEach visitor gets their own personal scribe â€” writing only their story.â€

ğŸ§¬ Lifecycle Hooks
Purpose:
Understand how NestJS components (Modules, Controllers, Providers) go through creation â†’ initialization â†’ destruction phases.



Hook
Trigger
Typical Use
OnModuleInit
When the moduleâ€™s dependencies are resolved
Warm-up caches, log startup
OnApplicationBootstrap
When all modules initialized
Startup tasks (seed data, connect services)
OnModuleDestroy
Before module destroyed
Cleanup (close DB)
OnApplicationShutdown
App shutdown signal received
Graceful shutdown

ğŸ’» Lifecycle Hooks
Task:
Add OnModuleInit to GuildsService and log initialization.
Add OnApplicationBootstrap to AppModule and print a startup message.
Run npm run start:dev and watch the console.
Stop the server and observe shutdown logs.

Temple Unlock:
ğŸ§¬ Pulse of the Temple awakened â€” your services now live and breathe.


ğŸ’» Lifecycle Hooks
// any.service.ts
import { Injectable, OnModuleInit, OnApplicationShutdown } from '@nestjs/common';

@Injectable()
export class AnyService implements OnModuleInit, OnApplicationShutdown {
  onModuleInit() { console.log('AnyService ready âœ…'); }
  onApplicationShutdown(signal?: string) { console.log('Shutting down:', signal); }
}


ğŸŒŠ Pipes & Filters
Purpose:
Transform & validate incoming data; handle errors gracefully.

Key Topics:
Built-in pipes: ValidationPipe, ParseIntPipe, ParseUUIDPipe
Creating custom pipes
Exception filters (@Catch, ArgumentsHost)
Built-in exceptions (BadRequestException, NotFoundException)
Global pipes & filters setup


ğŸŒŠ Pipes & Filters
// dto & validation pipe usage
import { IsString, Length } from 'class-validator';
export class CreateGuildDto {
    @IsString() @Length(3, 30) name!: string;
}

// global in main.ts
app.useGlobalPipes(new ValidationPipe({ whitelist: true }));

// custom filter
@Catch(HttpException)
export class HttpFilter implements ExceptionFilter {
  catch(e: HttpException, host: ArgumentsHost) {
    const res = host.switchToHttp().getResponse();
    res.status(e.getStatus()).json({ message: e.message });
  }
}



@PipeTransform()
export class ParseIntPipe implements PipeTransform {
  transform(value: string) {
    const val = parseInt(value, 10);
    
    if (isNaN(val)) 
        throw new BadRequestException('Not a number');
    
     return val;
  }
}


ğŸŒŠ Pipes & Filters
Hands-on Quest:
Add DTO validation using class-validator.
Create custom pipe (UppercaseNamePipe) & exception filter for 404 handling.


ğŸŒ Global Filters
Purpose:
Apply exception handling across the entire app â€” no need to repeat @UseFilters() everywhere.

Concepts:
Register filters globally with the APP_FILTER token.
Handle exceptions in one central place.

@Catch(HttpException)
export class GlobalExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const res = host.switchToHttp().getResponse<Response>();
    const status = exception.getStatus();
    res.status(status).json({
      statusCode: status,
      message: exception.message,
      temple: 'Module of Light',
    });
  }
}


ğŸŒ Global Filters
Register globally:

@Module({
  providers: [{ provide: APP_FILTER, useClass: GlobalExceptionFilter }],
})
export class AppModule {}


â€œA single guardian stands watch â€” protecting every chamber from chaos.â€

ğŸ•°ï¸ Checkpoint
Temple Status:
âœ… Modules
âœ… Controllers
âœ… Providers & DI
âœ… Pipes & Filters

Today You Learned:
How NestJS structures apps via modules
How controllers route HTTP requests
How providers inject logic dynamically
How pipes and filters ensure clean input & error handling



ğŸ•°ï¸ Checkpoint
Artifacts Earned:
ğŸ›ï¸ Gate of Structure
âš”ï¸ Controllerâ€™s Blade
ğŸ’¡ Lantern of Dependency
ğŸŒŠ Pipe of Purity

â€œThe Temple glows brighter â€” tomorrow, we build its heart: Data & Persistence.â€




Day 2

ğŸ§­ The Heart of the Temple
Theme:
ğŸ§± Building the Templeâ€™s Foundation â€” Data, Queries, and Secrets

Focus Areas:
Persistence (TypeORM vs MikroORM)
GraphQL
Authentication (JWT + Guards + Interceptors)

End of Day Goal:
A fully functional NestJS backend connected to a database, queried via GraphQL, and protected by authentication.


ğŸ“… Agenda
 
Time
Module
Concept
Format
9:30 â€“ 10:30
Recap
Review Day 1 + Setup DB
Discussion
10:30 â€“ 11:00
Chamber 5
ğŸ§± Persistence (TypeORM vs MikroORM)
Lecture + Hands-on
11:00 â€“ 12:00
Chamber 6
ğŸ”® GraphQL
Lecture + Hands-on
12:00 â€“ 13:30
â€”
Lunch Break
ğŸœ
13:30 â€“ 14:30
Chamber 7
ğŸ” Authentication (JWT) 
Lecture + Hands-on
14:00 â€“ 16:00
Chamber 8
ğŸ›¡ï¸ Guards & Interceptors & Middlewares
Lecture + Hands-on
16:00 â€“ 16:30
â€”
Recap & Temple Checkpoint 2
Discussion

ğŸ§± Persistence (TypeORM vs MikroORM)
Purpose:
Give the temple a foundation â€” structured data, models, and repositories.

Key Topics:
Setting up database connection
Entities & Repositories
Migrations
Relationships (1:N, N:M)
Lazy vs Eager loading
Difference between TypeORM & MikroORM
Lifecycle hooks e.g @BeforeInsert



ğŸ§© TypeORM vs MikroORM
 
Feature
TypeORM
MikroORM
Style
Decorator-based (Active Record or Data Mapper)
Pure Data Mapper
Config
Simple, but less explicit
Explicit & flexible
Query Builder
Built-in
Built-in, lightweight
Entity Lifecycle
Auto-managed
Fully manual control
Schema Sync
Auto sync
Migration-driven
Decorators
Heavy usage
Minimalist

ğŸ§± Persistence (TypeORM vs MikroORM)
// TypeORM entity
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from 'typeorm';
@Entity() 
export class Guild {
  @PrimaryGeneratedColumn('uuid') id!: string;
  @Column() name!: string;
  @CreateDateColumn() createdAt!: Date;
}


// MikroORM entity
import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
@Entity() 
export class Guild {
  @PrimaryKey() id: string = crypto.randomUUID();
  @Property() name!: string;
  @Property({ onCreate: () => new Date() }) createdAt!: Date;
}


ğŸ§± Persistence (TypeORM vs MikroORM)

ğŸ§± Persistence (TypeORM vs MikroORM)

ğŸ’» Hands-On Quest
Task:
Install both ORMs: npm i typeorm mikro-orm 
Create GuildEntity and QuestEntity with id, name, createdAt and some more attributes of your choice.
Implement the same entity in both ORMs.
Add /guilds CRUD using repository pattern.

Stretch Challenge:
Add QuestEntity with a relation to GuildEntity and query all guilds with their quests.

Temple Unlock:
ğŸ§± Bricks of Persistence placed.


ğŸ”® GraphQL
Purpose:
Unleash flexible querying power for the temple.

Key Topics:
Installing and setting up @nestjs/graphql
Code-first schema (@ObjectType, @Field, @Resolver)
Queries vs Mutations
Nested resolvers & DataLoader
GraphQL Playground
Schema generation


ğŸ§© GraphQL Architecture
Flow:
Request â†’ Resolver
Resolver calls Service
Service â†’ DB (ORM)
Data returned to GraphQL runtime
Response matches schema types

@Module({
  imports: [
    GraphQLModule.forRootAsync({
      driver: ApolloDriver,
      inject: [GuildService, QuestService],
      useFactory: (guilds: GuildService, quests: QuestService) => ({
        autoSchemaFile: true,
        context: () => ({
          loaders: {
            questsByGuild: createQuestsByGuildLoader(quests),
          },
        }),
      }),
    }),
  ],
  providers: [GuildService, QuestService, QuestResolver, GuildResolver],
})
export class AppModule {}

ğŸ”® GraphQL

// loaders/create-quests-by-guild.loader.ts
import DataLoader from 'dataloader';
import { QuestService } from '../quest.service';
import { Quest } from '../quest.entity';

export function createQuestsByGuildLoader(quests: QuestService) {
  return new DataLoader<number, Quest[]>(async (guildIds) => {
    const rows = await quests.findManyByGuildIds(guildIds);
    // Bucket quests by guildId
    const buckets = new Map<number, Quest[]>();

    for (const id of guildIds) 
       buckets.set(id, []);

    for (const q of rows) 
       buckets.get(q.guildId)!.push(q);

    return guildIds.map(id => buckets.get(id)!); // array per guildId, in order
  });
}

ğŸ”® GraphQL

// gql.module.ts
GraphQLModule.forRoot({ autoSchemaFile: true });

// types & resolver
@ObjectType() 
class Guild { 
   @Field() 
    id!: string; 
   
    @Field() 
    name!: string; 
    
    @Field(() => [Quest]) 
    quests: [Quest]; 
}
ğŸ”® GraphQL
@Resolver(() => Guild)
export class GuildResolver {
    constructor(private svc: GuildsService) {}

    @Query(() => [Guild])
     guilds() {
        return this.svc.list();
     }

     @Mutation(() => Guild)
     createGuild(@Args('name') name: string) {
         return this.svc.create(name);
      }

    @ResolveField(() => [Quest])
    quests(@Parent() guild: Guild, @Context() ctx: any) {
        // âœ… Batch quests for multiple guilds in one go
        return ctx.loaders.questsByGuild.load(guild.id);
    }
}


ğŸ”® GraphQL DataLoader
Purpose:
Solve the N + 1 problem in GraphQL by batching and caching related queries.

Problem:
Without DataLoader, your resolver might trigger dozens of DB calls â€”
e.g., fetching quests for each guild separately.

Solution:
DataLoader groups similar requests into one efficient query.


âš™ï¸ How Data Loader Works
Flow:
Multiple resolvers ask for related data (e.g., Guild â†’ Quests).
DataLoader collects all IDs requested within the same tick.
It calls a single batch function (e.g., findManyByGuildIds).
Results are cached and returned in the same order.

Analogy:
â€œInstead of asking the librarian for one book at a time, you hand her a list â€” she brings them all at once.â€ ğŸ“š


ğŸ”® GraphQL DataLoader
// quests.loader.ts
import  DataLoader from 'dataloader';
import { Injectable } from '@nestjs/common';
import { QuestsService } from './quests.service';

@Injectable()
export class QuestsLoader {
  constructor(private readonly quests: QuestsService) {}

  readonly loader = new DataLoader<string, Quest[]>(async (guildIds) => {
    const quests = await this.quests.findByGuildIds(guildIds);
    const map = groupBy(quests, 'guildId');
    return guildIds.map((id) => map[id] || []);
  });
}




ğŸ”® GraphQL DataLoader
// graphql.module.ts
GraphQLModule.forRoot({
  autoSchemaFile: true,
  context: () => ({
    loaders: {
      quests: new QuestsLoader(),
    },
  }),
});

// guild.resolver.ts
@Resolver(() => Guild)
export class GuildResolver {
  @ResolveField(() => [Quest])
  quests(@Parent() guild: Guild, @Context() ctx) {
    return ctx.loaders.quests.loader.load(guild.id);
  }
}


ğŸ’» Hands-On Quest
Task:
Add @nestjs/graphql, graphql, apollo-server-express.
Create Guild and Quest object types.
Add resolvers for queries and mutations for Guild and Quest entities
Implement DataLoader to avoid N+1 queries to get the quests for a guild.
Test in GraphQL Playground.

Temple Unlock:
ğŸ”® Orb of Queries activated â€” data flows through light.


ğŸ’¾ Caching in NestJS
Purpose:
Reduce redundant queries and boost performance by caching responses in memory or Redis. Install with npm i @nestjs/cache-manager cache-manager
To register in module:
CacheModule.register({ ttl: 10 }); // 10 seconds

ğŸ’¾ Caching in NestJS
// app.service.ts
import { Injectable, Inject, CACHE_MANAGER } from '@nestjs/common';
import { Cache } from 'cache-manager';

@Injectable()
export class AppService {
  constructor(@Inject(CACHE_MANAGER) private cache: Cache) {}

  async getUserData(id: number) {
    const key = `user_${id}`;

    // 1ï¸âƒ£ Try from cache first
    let user = await this.cache.get(key);
    if (user) {
      console.log('âœ… Returned from cache');
      return user;
    }

    

    // 2ï¸âƒ£ Otherwise fetch from â€œDBâ€ or API
    console.log('âš™ï¸ Fetching from DB...');
    user = { id, name: 'Ada Lovelace', role: 'Engineer' };

    // 3ï¸âƒ£ Store in cache for 15 seconds
    await this.cache.set(key, user, 15_000);

    return user;
  }
}


ğŸ’¾ Caching in NestJS
Example
import { CacheInterceptor, CacheKey, CacheTTL, UseInterceptors } from '@nestjs/common';

@Controller('guilds')
@UseInterceptors(CacheInterceptor)
export class GuildsController {
  @CacheKey('all_guilds')
  @CacheTTL(30)
  @Get()
  findAll() {
    return [{ id: 1, name: 'Dev Rangers' }];
  }

}


âš™ï¸ Hands-On Quest: Caching
Task:
Enable CacheModule in AppModule.
Cache responses for /guilds endpoint.
Log requests â€” note skipped DB calls on subsequent hits.

Temple Unlock:
ğŸ’¾ Memory Chamber awakened â€” the temple now remembers.




ğŸ“‚ File Uploads in NestJS
Purpose:
Handle image and document uploads using Multer and interceptors. Install with npm i @nestjs/platform-express multer

import { FileInterceptor } from '@nestjs/platform-express';

@Post('upload')
@UseInterceptors(FileInterceptor('file'))
upload(@UploadedFile() file: Express.Multer.File) {
  console.log(file.originalname);
  return { message: 'File uploaded', filename: file.filename };
}

To upload multiple files:
@UseInterceptors(FilesInterceptor('files'))



ğŸ§  Hands-On Quest: File Uploads
Task:
Add /upload route for single file.
Test with Postman (form-data).
Save uploads in /uploads folder.
Display uploaded file names via /files route.

Temple Unlock:
ğŸ“‚ Vault of Offerings opened â€” files accepted by the temple.


ğŸ” Authentication (JWT + Passport)
Purpose:
Protect the temple with guards and tokens.

Key Topics:
Passport module integration
Local & JWT strategy setup
Guards with @UseGuards(AuthGuard('jwt'))
Refresh tokens
Password hashing (bcrypt)




ğŸ” Authentication (JWT + Passport)
@Module({
  imports: [
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'dev_secret',   // use env in prod
      signOptions: { expiresIn: '1h' },
    }),
  ],
  controllers: [AuthController],
  providers: [JwtStrategy],
  exports: [PassportModule, JwtModule],
})
export class AuthModule {}



ğŸ” Authentication (JWT + Passport)
@Module({
  imports: [
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'dev_secret',   // use env in prod
      signOptions: { expiresIn: '1h' },
    }),
  ],
  controllers: [AuthController],
  providers: [JwtStrategy],
  exports: [PassportModule, JwtModule],
})
export class AuthModule {}



ğŸ” Authentication (JWT + Passport)
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: 'secret',
    });
  }

  validate(payload) {
    return { userId: payload.sub, email: payload.email };
  }
}


ğŸ” Authentication (JWT + Passport)
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}


// usage
@Controller('profile')
export class AuthController {
  @Get()
  @UseGuards(JwtAuthGuard)
  me(@Req() req: any) {
    // req.user was set by JwtStrategy.validate()
    return { me: req.user };
  }
}


ğŸ” Authentication (JWT + Passport)
import {
  CanActivate, ExecutionContext, Injectable, UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class JwtCustomGuard implements CanActivate {
  constructor(private readonly jwt: JwtService) {}

  async canActivate(ctx: ExecutionContext): Promise<boolean> {
    const req = ctx.switchToHttp().getRequest();
    const auth = req.headers['authorization'] as string | undefined;

    if (!auth?.startsWith('Bearer ')) {
      throw new UnauthorizedException('Missing or invalid Authorization header');
    }

    try {
      // Verify token manually
      const payload = await this.jwt.verifyAsync(token, {
        secret: process.env.JWT_SECRET || 'dev_secret',
      });

      // Attach to request (mimicking Passportâ€™s req.user)
      req.user = { userId: payload.sub, email: payload.email, roles: payload.roles ?? [] };

      return true;
    } catch {
      throw new UnauthorizedException('Token invalid or expired');
    }
  }
}


ğŸ” Authentication (JWT + Passport)
import { Controller, Get, UseGuards, Req } from '@nestjs/common';
import { JwtCustomGuard } from './jwt-custom.guard';
import { JwtModule } from '@nestjs/jwt';

@Controller('profile-custom')
export class ProfileCustomController {
  @Get()
  @UseGuards(JwtCustomGuard)
  whoAmI(@Req() req: any) {
    return { me: req.user };
  }
}


ğŸ’» Hands-On Quest
Task:
Install @nestjs/passport, @nestjs/jwt, passport-jwt.
Add AuthModule with AuthService and UsersService.
Implement /auth/login â†’ returns JWT.
Protect /guilds routes with JWT guard.
Test with Postman using Authorization: Bearer <token>. (if time permits)

Temple Unlock:
ğŸ” Key of Trust obtained â€” vault secured.



ğŸ›¡ï¸ Guards & Interceptors
Purpose:
Add advanced control and response manipulation.

Key Topics:
Guards (CanActivate, ExecutionContext)
Role-based access
Interceptors
Logging, transformation, timing
Order of execution 

(Client â†’ Middleware â†’ Guards â†’ Pipes â†’ Interceptors â†’ Controllers/Resolvers â†’ Services â†’ Middleware  â†’ Response)


â€œGuards control who enters. Interceptors control what happens next.â€



ğŸ›¡ï¸ Guards & Interceptors
// roles.guard.ts
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(ctx: ExecutionContext) {
    return ctx.switchToHttp().getRequest().user?.role === 'admin';
  }
}

// logging.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { tap } from 'rxjs/operators';
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(ctx: ExecutionContext, next: CallHandler) {
    const t = Date.now(); return next.handle().pipe(tap(() => console.log('Time:', Date.now()-t,'ms')));
  }
}


ğŸ’» Hands-On Quest
Task:
Create RolesGuard to restrict admin-only routes.
Add LoggingInterceptor to log response times.
Combine with AuthGuard for layered access control.
Use custom decorator @Roles('admin').

Temple Unlock:
ğŸ›¡ï¸ Guardianâ€™s Shield forged â€” control achieved.


âš™ï¸ Middleware
Purpose:
Handle logic before a request reaches controllers â€” logging, auth checks, or data enrichment.

Key Topics:
Middleware lifecycle and execution order
Difference from Guards & Interceptors
Applying middleware globally or per-route
Built-in vs custom middleware
Combining middleware with Guards & JWT

ğŸ’¡ Analogy:
Middleware = Temple Gatekeeper (checks every visitor)
Guard = Room Sentinel (checks specific chamber access)
Interceptor = Sage (observes and transforms)





âš™ï¸ Middleware
// logger.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req, res, next) { console.log(`[${req.method}] ${req.url}`); next(); }
}

// app.module.ts
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes('*');
  }
}


ğŸ§± Hands-On Quest: Middleware
Task:
Create a LoggerMiddleware that logs method, URL, and response time.
Apply it only to /auth and /guilds routes.
Create an AuthMiddleware that rejects missing Authorization headers.
Test combined flow:
Unauthorized request blocked by middleware
Authorized request hits Guard + Controller

Temple Unlock:
âš™ï¸ Mechanism of Vigilance â€” the Temple gains awareness of every visitor.



âš™ï¸ Background Jobs
In real-world apps, not all tasks should happen during an HTTP request.
Background jobs handle long-running or non-critical work asynchronously â€” such as:
	â€¢	Sending emails
	â€¢	Generating reports or invoices
	â€¢	Processing uploads
	â€¢	Syncing data with external APIs
	â€¢	Running scheduled maintenance tasks

In NestJS, we can implement this through:
	1.	ğŸ‚ Bull / BullMQ Queues â€” persistent, Redis-based job queues
	2.	â° ScheduleModule (Cron Jobs) â€” periodic jobs (every X seconds/minutes/days)
	3.	ğŸ§µ Worker Threads / Async Services â€” for compute-intensive tasks


ğŸ§± 1. Bull / BullMQ Queues (Redis-based Jobs)

ğŸ§± 1. Bull / BullMQ Queues (Redis-based Jobs)

ğŸ§± 1. Bull / BullMQ Queues (Redis-based Jobs)

â° 2. ScheduleModule (Cron Jobs)
Purpose
Execute recurring tasks (daily cleanups, reports, cache refreshes) without a queue.Install with npm i @nestjs/schedule



ğŸ§µ 3. Worker Threads (CPU-bound Tasks)
Use when a task is CPU intensive and blocks the Node.js event loop (e.g., image processing, large dataset parsing).


ğŸ§° Best Practices for Background Jobs
ğŸ§° Best Practices for Background Jobs
Idempotence â€“ Jobs should be safely re-runnable.
Retries â€“ Use Bullâ€™s attempts and backoff options.
Monitoring â€“ Expose /metrics or use Bull Board.
Separation â€“ Run workers as separate Nest apps (avoid blocking API).
Graceful Shutdown â€“ Close connections in onApplicationShutdown.
Prioritization â€“ Use job priorities in queue definitions.
Security â€“ Never execute user-supplied code in workers.


ğŸ§© Hands-On Quest: Background Jobs
Goal:
Create an emails queue using Bull.
Add an endpoint /guilds/notify that enqueues a notification with a given email.
Create a EmailProcessor that logs "Temple notification sent to guild X".
Add a cron job that cleans up expired guilds every minute. (we created guilds in persistence chamber)

Temple Unlock:
âš™ï¸ Engines of the Temple activated â€” your workers now serve in silence.


ğŸ§  Recap
Today You Learned:
Database persistence (TypeORM vs MikroORM)
GraphQL setup and resolvers
JWT Authentication with Passport
Middleware & request pre-processing 
Guards & Interceptors for route protection and transformation
Background working Jobs/ Queues

Artifacts Earned:
ğŸ§± Bricks of Persistence
ğŸ”® Orb of Queries
ğŸ” Key of Trust
âš™ï¸ Mechanism of Vigilance 
ğŸ›¡ï¸ Guardianâ€™s Shield

â€œThe Temple now guards itself â€” alert, aware, and strong.â€


Day 3

ğŸ¯ The Living Temple
Theme:
ğŸ“¡ Giving the Temple Life, Voice, and Vision

Focus Areas:
WebSockets (real-time updates)
Microservices (asynchronous communication)
Observability (health, metrics, logs)
Dockerization & Final Deployment
Golden Module Celebration ğŸ‰

End of Day Goal:
A running distributed NestJS system that communicates in real-time, logs its heartbeat, and shines as the final Golden Module.

ğŸ“… Agenda
 
Time
Module
Concept
Format
10:00 â€“ 10:30
Recap
Review Day 2 + Setup
Discussion
10:30 â€“ 11:00
Chamber 9
ğŸ“¡ WebSockets
Lecture + Hands-on
11:00 â€“ 12:00
Chamber 10
âš™ï¸ Microservices
Lecture + Hands-on
12:00 â€“ 13:30
â€”
Lunch Break
ğŸ±
13:30 â€“ 14:30
Chamber 11
ğŸ‘ï¸ Observability
Lecture + Hands-on
14:30 â€“ 15:30
Chamber 12
ğŸ³ Docker & Deployment
Lecture + Setup
15:30 â€“ 16:00
â€”
Golden Module Ceremony
Celebration ğŸ‡
16:00 - 16:30
â€”
Closing remarks + feedback + discussion
Casual

ğŸ“¡ WebSockets
Purpose:
Allow the temple to speak in real time â€” connect chambers instantly.

Key Topics:
@WebSocketGateway() and Socket.IO
Events (@SubscribeMessage())
Broadcasting to clients
Integrating with Auth Guards

Analogy:
â€œControllers speak once. Gateways whisper continuously.â€


ğŸ’» Demo
Gateway example:
@WebSocketGateway({ cors: true })
export class TempleGateway {
  @WebSocketServer() 
   server: Server;

  @SubscribeMessage('questCompleted')
  onQuestCompleted(client: Socket, data: any) {
    this.server.emit('templeUpdate', { message: 'Temple glows brighter!' });
  }
}


Client Example (Browser):

const socket = io('http://localhost:3000');
socket.on('templeUpdate', (msg) => console.log(msg));




ğŸ“¡ WebSockets
Hands-On Quest:
Implement TempleGateway.
Broadcast events when a quest is completed.
Update console with Temple progress.

Temple Unlock:
ğŸ“¡ Beacon of Real-Time activated â€” voices echo across chambers.




âš™ï¸ Microservices
Purpose:
Connect distributed temple services through messages instead of HTTP.

Key Topics:
Message-based communication
ClientProxy and @MessagePattern()
Transport layers (TCP, Redis, NATS)
Worker services & background tasks
Integration with event-driven flows


âš™ï¸ Microservices
Temple Worker Example:

// temple.worker.ts
@MessagePattern('temple.event')
handleTempleEvent(data: any) {
  console.log('Temple Worker received:', data);
}

Main API:

// temple.gateway.ts
constructor(@Inject('TEMPLE_SERVICE') private client: ClientProxy) {}

emitTempleEvent() {
  this.client.emit('temple.event', { type: 'GLOW', time: new Date() });
}


âš™ï¸ Microservices
Hands-On Quest:
Create a second Nest app (worker).
Connect via TCP transport.
Emit events from API â†’ process in worker.

Temple Unlock:
âš™ï¸ Cog of Harmony spins â€” the temple communicates across realms.




ğŸ§  Event Emitter
Purpose:
Enable in-app async communication via events â€” no HTTP, no direct dependency.  Install with npm i @nestjs/event-emitter

Analogy
â€œWhispers echo through the temple halls â€” the chambers now speak to one another.â€

ğŸ§  Event Emitter
// app.module.ts
import { EventEmitterModule } from '@nestjs/event-emitter';
@Module({ imports: [EventEmitterModule.forRoot()] })
export class AppModule {}

// guilds.service.ts
this.eventEmitter.emit('guild.created', { name: 'Ruby Rangers' });

// guilds.listener.ts
@OnEvent('guild.created')
handleGuildCreated(payload: any) {
  console.log('Temple Event:', payload.name);
}

ğŸ’¡ Hands-On Quest: Event Emitter
Task:
Emit quest.completed event from controller.
Handle it in a listener that logs the quest name.
Chain events: quest.completed â†’ emits temple.glow.

Temple Unlock:
ğŸ”” Echoes of the Temple â€” asynchronous wisdom shared.



ğŸ§ª Testing in NestJS
Purpose:
Validate each temple chamberâ€™s strength â€” test controllers, services, and modules.

Setup:
npm i -D @nestjs/testing jest @types/jest ts-jest
npx jest --init





ğŸ§ª Testing in NestJS
E2E Test Example
describe('GuildsController (e2e)', () => {
  it('/GET guilds', () => {
    return request(app.getHttpServer())
      .get('/guilds')
      .expect(200);
  });
});





ğŸ§ª Testing in NestJS
Unit Test Example

describe('GuildsService', () => {
  let service: GuildsService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [GuildsService],
    }).compile();

    service = module.get(GuildsService);
  });

  it('should create a guild', () => {
    const guild = service.create('Ruby Rangers');
    expect(guild.name).toBe('Ruby Rangers');
  });
});



ğŸ§© Hands-On Quest: Testing
Task:
Write a unit test for your service.
Write one E2E test for /guilds.
Run all tests via npm run test.
Celebrate with a green âœ….

Temple Unlock:
ğŸ§ª Seal of Stability earned â€” the temple stands unshaken.


ğŸ‘ï¸ Observability
Purpose:
Grant the temple sight â€” track health, metrics, and readiness.

Key Topics:
Health endpoints (@nestjs/terminus)
Metrics with Prometheus (/metrics)
Centralized logging (PinoLogger / Winston)


Tip:
â€œA temple that cannot see its own light will fall in darkness â€” observability prevents blindness.â€


ğŸ‘ï¸ Observability
// app.module.ts
import { LoggerModule } from 'nestjs-pino';

@Module({
  imports: [
    LoggerModule.forRoot({
      pinoHttp: {
        transport: { target: 'pino-pretty' }, // readable console logs
        level: process.env.LOG_LEVEL || 'info',
      },
    }),
  ],
})
export class AppModule {}


ğŸ‘ï¸ Observability
import { PinoLogger } from 'nestjs-pino';
import { Injectable } from '@nestjs/common';

@Injectable()
export class GuildsService {
  constructor(private readonly logger: PinoLogger) {
    this.logger.setContext(GuildsService.name);
  }

  create(name: string) {
    this.logger.info(`Creating guild: ${name}`);
    return { id: Date.now(), name };
  }
}

Output:
{"time":"2025-10-12T21:00:00Z","level":"info","msg":"Creating guild: Ruby Rangers","context":"GuildsService"}



ğŸ’» Hands-On Quest
Task:
Add /health route using TerminusModule.
Configure Pino logger for logging
Print request method, URL, and status in logs.

Stretch Challenge:
Add X-Request-ID middleware and include in logs.

Temple Unlock:
ğŸ‘ï¸ Eye of Insight opens â€” temple becomes self-aware.


âš™ï¸ ConfigService
Purpose:
Centralize configuration (API keys, DB creds, ports) with @nestjs/config.

Key Benefits:
Reads .env files automatically
Supports type-safe config
Can validate schema via Joi
Works seamlessly with dynamic modules

Analogy: 
â€œConfigService is the templeâ€™s scroll of secrets â€” all sacred keys, kept in one safe place.â€




âš™ï¸ ConfigService
// app.module.ts
import { ConfigModule, ConfigService } from '@nestjs/config';
@Module({ 
imports: [ConfigModule.forRoot({ isGlobal: true })] 
}) 
export class AppModule {}

// usage in service
@Injectable()
export class StartupService {
  constructor(private cfg: ConfigService) {}
  port() { console.log('PORT =', this.cfg.get('PORT', 3000)); }
}


ğŸ’» Hands-On Quest: ConfigService
Task:
Add .env with custom values.
Inject ConfigService into AppModule and GuildsService.
Print config values during startup.
Validate your .env using Joi schema.

Temple Unlock:
ğŸ“œ Scroll of Secrets discovered â€” configuration mastered.



ğŸ³ Docker & Deployment
Purpose:
Contain and preserve the temple for eternity.

Key Topics:
Dockerfile & .dockerignore
Environment configuration for containers
docker-compose for multi-service setup
Building and running Nest apps in production

Tip:
â€œThe temple must survive beyond your laptop â€” Docker is its sarcophagus of immortality.â€


ğŸ The Golden Module
Final Ceremony:
All Chambers completed âœ…
Golden Module unlocked âœ¨






â€œThe Temple of Modules glows with golden light â€”
your journey is complete.â€ ğŸŒŸ

Artifacts Earned:
ğŸ›ï¸ Gate of Structure
âš”ï¸ Controllerâ€™s Blade
ğŸ’¡ Lantern of Dependency
ğŸŒŠ Pipe of Purity
ğŸ§± Bricks of Persistence
ğŸ”® Orb of Queries
ğŸ” Key of Trust
âš™ï¸ Mechanism of Vigilance
ğŸ›¡ï¸ Guardianâ€™s Shield
ğŸ“¡ Beacon of Real-Time
âš™ï¸ Cog of Harmony
ğŸ‘ï¸ Eye of Insight
ğŸ³ Vault of Eternity






ğŸ’» Hands-On Quest
Create a dockerfile
FROM node:20
WORKDIR /app
COPY package*.json ./
RUN npm install --only=production
COPY . .
CMD ["npm", "run", "start:prod"]


   2.	Build & run:
docker build -t temple-api .
docker run -p 3000:3000 temple-api

   3. 	Create docker-compose.yml for API + Worker + DB.

Temple Unlock:
ğŸ³ Vault of Eternity sealed â€” the temple endures across machines.


ğŸ“ Recap
You are now:
ğŸ… Certified Temple Builder of NestJS
(aka: â€œFull-Stack Backend Warriorâ€)

Youâ€™ve mastered:
âœ… Modular architecture
âœ… Dependency Injection
âœ… ORMs + GraphQL
âœ… Auth + Middleware
âœ… WebSockets + Microservices
âœ… Observability + Docker



ğŸ’¬ Reflections & Next Steps
Reflect:
What was your favorite Chamber?
What challenged you the most?
How will you use NestJS in production?

Next Steps:
Explore CQRS, Event-Driven Design, or MicroFrontends.
Build your own module library.


â€œA true Temple Builder never stops learning.â€


ğŸ™ Thank You
Over the past 3 days, youâ€™ve built, debugged, and discovered. Youâ€™ve mastered the art of modular design, the elegance of dependency injection, and the power of collaboration and curiosity.

As you leave the Templeâ€¦
Keep your code modular ğŸ§±
Keep your mind curious ğŸ’¡
Keep your community strong ğŸ¤
And always remember: the framework is just a tool â€” you are the architect. ğŸ—ï¸


Thank you for lighting the Temple with your brilliance âœ¨ Until the next questâ€¦ stay curious, and keep building. âœ¨


